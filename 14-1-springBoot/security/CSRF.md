### **Cross-Site Request Forgery (CSRF)**

**Cross-Site Request Forgery (CSRF)** is a type of web security vulnerability where an attacker tricks a victim into performing unintended actions on a trusted website where the victim is authenticated. This can lead to unauthorized actions like changing account settings, transferring funds, or performing administrative actions.

---

### **How CSRF Works**

1. **Victim Authentication**:
   - The victim logs into a trusted website (e.g., `bank.com`) and receives an authentication token (usually a session cookie).

2. **Attacker's Setup**:
   - The attacker creates a malicious website (e.g., `evil.com`) with scripts or forms that issue requests to the trusted site.

3. **Victim Visits Malicious Site**:
   - The victim visits the malicious site (`evil.com`) while still logged into `bank.com`.

4. **Unauthorized Request**:
   - The malicious site makes requests to `bank.com` using the victim's browser. Because the browser automatically includes the victim's session cookie, `bank.com` interprets the request as legitimate and processes it.

---

### **Example of a CSRF Attack**

#### **Scenario: Changing a User's Email**
1. The victim is logged into `bank.com`.
2. The attacker crafts a form on `evil.com` like this:
   ```html
   <form action="https://bank.com/change-email" method="POST">
       <input type="hidden" name="email" value="attacker@example.com">
       <input type="submit" value="Click me!">
   </form>
   ```
3. When the victim visits `evil.com` and submits the form (or the form submits automatically using JavaScript), `bank.com` processes the request because the victim's session cookie is sent along with the request.

---

### **Key Characteristics of CSRF**
- Relies on the victim's authenticated session with the target website.
- Exploits the trust that a web application has in the user's browser.
- Targets state-changing actions (e.g., form submissions, POST requests).

---

### **Preventing CSRF**
Modern web applications must employ strategies to prevent CSRF. These strategies include:

#### **1. CSRF Tokens**
- A **CSRF token** is a unique, unpredictable value generated by the server and included in forms or requests.
- The server validates the token on every request to ensure it matches the session.
  
**Implementation**:
1. Generate a CSRF token when the session is created.
2. Embed the token in the web forms:
   ```html
   <input type="hidden" name="csrf_token" value="abc123">
   ```
3. Validate the token on the server before processing the request.

**Spring Security**:
- Spring Security automatically protects against CSRF by enabling it in the security configuration.
  ```java
  @Override
  protected void configure(HttpSecurity http) throws Exception {
      http.csrf().enable();
  }
  ```

---

#### **2. SameSite Cookies**
- The `SameSite` cookie attribute prevents cookies from being sent along with cross-site requests.

**Example**:
```http
Set-Cookie: sessionid=abc123; SameSite=Strict
```
- **`Strict`**: The cookie is sent only for same-site requests.
- **`Lax`**: Allows the cookie for some cross-origin GET requests.

---

#### **3. CORS (Cross-Origin Resource Sharing)**
- Restricts which origins are allowed to send requests to the server.
- Configure the server to allow requests only from trusted origins.

**Spring Security**:
```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http.cors().and().csrf().disable();
}
```
- Use CORS and CSRF in tandem for robust protection.

---

#### **4. Avoiding GET for State-Changing Actions**
- Use `POST` for actions that modify the application state.
- Avoid making state-changing operations idempotent or bookmarkable.

---

### **Testing for CSRF Vulnerabilities**
You can use tools like:
- **OWASP ZAP**: Automates CSRF vulnerability scans.
- **Burp Suite**: Tests and exploits CSRF vulnerabilities.
- **Custom Scripts**: Use a malicious HTML form or JavaScript to test requests.

---

### **Key Challenges**
- CSRF tokens must be securely transmitted and verified.
- CSRF prevention mechanisms may require additional developer effort for SPA frameworks.

---
### **Implementing CSRF Protection in Spring Security**

Spring Security provides built-in support for CSRF protection and includes it in the default security configuration. Below are examples demonstrating how to implement and customize CSRF protection.

---

### **1. Enabling CSRF Protection (Default Configuration)**

By default, Spring Security enables CSRF protection. When you set up Spring Security in a Spring Boot application, CSRF protection is already applied to your application. Here’s a basic example:

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .csrf().enable()  // CSRF protection is enabled by default
            .and()
            .authorizeRequests()
            .anyRequest().authenticated();
    }
}
```

#### **Behavior**:
- All state-changing HTTP methods (like `POST`, `PUT`, `DELETE`) will require a CSRF token.
- GET, HEAD, TRACE, and OPTIONS requests are exempt from CSRF checks as they are considered safe.

---

### **2. Customizing CSRF Protection**

You can customize how CSRF tokens are generated, included, and validated.

#### **A. Specifying CSRF Token Repository**
The `CsrfTokenRepository` defines how tokens are stored. Spring Security provides `HttpSessionCsrfTokenRepository` and `CookieCsrfTokenRepository`.

##### **Example with HTTP Session:**
```java
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
        .csrf()
            .csrfTokenRepository(new HttpSessionCsrfTokenRepository())
        .and()
        .authorizeRequests()
            .anyRequest().authenticated();
    return http.build();
}
```

##### **Example with Cookies:**
```java
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
        .csrf()
            .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
        .and()
        .authorizeRequests()
            .anyRequest().authenticated();
    return http.build();
}
```

#### **B. Ignoring Specific Endpoints**
You can disable CSRF protection for certain endpoints like APIs or specific URLs.

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .csrf()
            .ignoringAntMatchers("/api/**")  // Ignore CSRF for API endpoints
        .and()
        .authorizeRequests()
            .anyRequest().authenticated();
}
```

---

### **3. Accessing and Sending CSRF Tokens**

#### **A. Embedding the Token in HTML Forms**
Spring Security automatically provides a CSRF token in the `HttpServletRequest`. Use Thymeleaf or JSP to include the token in your forms.

##### **Using Thymeleaf:**
```html
<form method="post" action="/submit">
    <input type="hidden" name="_csrf" th:value="${_csrf.token}" />
    <button type="submit">Submit</button>
</form>
```

##### **Using JSP:**
```jsp
<form method="post" action="/submit">
    <input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}" />
    <button type="submit">Submit</button>
</form>
```

---

#### **B. Including the Token in AJAX Requests**
For AJAX-based applications, you need to send the CSRF token in the request headers.

```html
<script>
    const token = document.querySelector('meta[name="_csrf"]').getAttribute('content');
    const header = document.querySelector('meta[name="_csrf_header"]').getAttribute('content');

    fetch('/submit', {
        method: 'POST',
        headers: {
            [header]: token,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ key: 'value' })
    });
</script>
```

Include the CSRF token and header name in your HTML `<head>`:
```html
<meta name="_csrf" content="${_csrf.token}" />
<meta name="_csrf_header" content="${_csrf.headerName}" />
```

---

### **4. Disabling CSRF (Not Recommended for Most Cases)**

If your application uses a stateless architecture (e.g., APIs with tokens like OAuth2 or JWT), CSRF protection may not be necessary. You can disable CSRF protection in such cases:

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .csrf().disable()  // Disable CSRF protection
        .authorizeRequests()
            .anyRequest().authenticated();
}
```

---

### **5. Advanced Customization: Adding CSRF Filter**

You can add a custom filter to handle CSRF tokens differently.

```java
@Bean
public SecurityFilterChain customSecurityFilterChain(HttpSecurity http) throws Exception {
    http
        .csrf()
            .csrfTokenRepository(new HttpSessionCsrfTokenRepository())
        .and()
        .addFilterAfter(new CustomCsrfFilter(), CsrfFilter.class)
        .authorizeRequests()
            .anyRequest().authenticated();
    return http.build();
}
```

Here’s a sample `CustomCsrfFilter`:
```java
public class CustomCsrfFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        CsrfToken csrfToken = (CsrfToken) request.getAttribute(CsrfToken.class.getName());
        if (csrfToken != null) {
            response.setHeader(csrfToken.getHeaderName(), csrfToken.getToken());
        }
        filterChain.doFilter(request, response);
    }
}
```

---

### **Key Takeaways**
- CSRF tokens are essential for protecting state-changing actions.
- Use `HttpSessionCsrfTokenRepository` or `CookieCsrfTokenRepository` for token storage.
- For SPAs, include CSRF tokens in AJAX headers.
- Customize or disable CSRF based on your application's architecture and security needs.

